

// 状态表示及转移
f[i][j] 表示 分成i段且最后一段必须包含a[j]的连续子序列
的集合。
根据a[j],可以如此划分集合：
1.a[j]不是单独成段。又因为最后一段必须包含a[j]且序列
连续，所以最后一段必包含a[j - 1]。
表示为f[i][j - 1] + a[j].
2.a[j]单独成段。所以剔除a[j]后，还剩i-1段，此时最后一段
也就是第i- 1段以谁结尾？是不确定的。
假设为a[k](i - 1<= k <= j - 1)。
表示为f[i - 1][k] + a[j].
3.所以f[i][j] = max(f[i][j - 1],f[i - 1][k]) + a[j].



// 边界处理
因为分成i段至少要有i个数，所以f[i][j]当i大于j时为不合法
所以f[i][i] 只能由第二种情况转移。
f[i][i] = f[i - 1][k] + a[i].k>= i - 1&&k <= i - 1
所以f[i][i] = f[i - 1][i - 1] + a[i]




//优化时间
发现转移时需要枚举k,大大增加了时间复杂度，对此优化。
因为不确定a[j - 1]是否被包含在第i-1段，所以需要枚举k
那能不能根据最后一个数是a[j - 1]来完成优化呢？
// 引入辅助数组 p[i][j].
p[i][j] 表示分为i段的连续子序列且最后一个数为a[j]的集合
注意：这里最后一段不一定需要包含a[j].
// p[i][j]的转移
1.最后一段必须包含a[j].此时p[i][j]的定义等同于f[i][j]
表示为f[i][j].
2.最后一段不包含a[j].表示为p[i][j - 1]
3. p[i][j] = max(p[i][j - 1],f[i][j]).
// 有了p[i][j]的定义后，发现f[i][k] == p[i][j - 1].
故f[i][j] = max(f[i][j - 1],p[i - 1][j - 1]) 
				+ a[j].
转移的时间复杂度由O(n)变为O(1)
